这是一份基于你所提供的“双塔博弈 + 闭环反馈”理念设计的完整 Agent 系统设计文档。该文档采用了 LangGraph 进行状态编排，结合 MCP 协议进行工具调用，旨在解决通用 LLM 无法生成高质量 Coccinelle (SmPL) 脚本的痛点。

-----

# 系统设计文档：Linux Kernel Semantic Patch Generator (LK-SPG) Agent

## 1\. 概述 (Executive Summary)

**目标**：构建一个基于 LLM 的智能 Agent 系统，专用于自动化生成 Linux Kernel 升级所需的 Coccinelle (SmPL) 语义补丁。
**核心痛点**：通用 LLM 倾向于将 SmPL 误认为 C 语言，导致语法错误和逻辑失效。
**解决方案**：采用 **"RAG-Augmented Iterative Refinement" (检索增强迭代优化)** 架构。系统不仅检索标准 SmPL 模式，还包含一个由编译器（`spatch`）驱动的反馈回路，强制 Agent 在输出最终结果前通过语法检查和 Mock 测试。

-----

## 2\. 系统架构 (System Architecture)

本系统基于 **LangGraph** 构建，采用有向循环图（DAG with Cycles）管理 Agent 状态。

### 2.1 核心角色 (Agents)

1.  **SmPL Architect (主架构师)**: 负责分析变更需求，结合 RAG 知识库，生成或修正 `.cocci` 脚本。
2.  **Test Engineer (测试工程师)**: 负责根据变更需求，编写一个最小可复现的 C 语言 Mock 文件（包含旧 API 调用），用于验证脚本是否生效。
3.  **Tool Executor (MCP Server)**: 负责执行本地 `spatch` 命令，返回标准输出/错误流。

### 2.2 状态定义 (State Schema)

在 LangGraph 中流转的全局状态对象 `AgentState`：

```python
from typing import TypedDict, List, Optional

class AgentState(TypedDict):
    user_request: str          # 用户输入的自然语言描述或 Git Diff
    retrieved_docs: List[str]  # 从 RAG 检索到的参考 SmPL 片段
    cocci_script: str          # 当前生成的 SmPL 脚本
    mock_c_code: str           # 用于测试的 Mock C 代码
    validation_output: str     # spatch 运行的输出 (stderr/stdout)
    patch_diff: str            # spatch 生成的 patch 结果
    iteration_count: int       # 循环次数 (防止死循环)
    error_log: List[str]       # 历史错误记录
    status: str                # "drafting", "validating", "fixing", "success", "failed"
```

-----

## 3\. 详细模块设计

### 3.1 知识库构建 (Targeted RAG)

这是 Agent 的“军火库”。我们需要构建一个专门理解 SmPL 模式的向量数据库。

**数据源与处理策略：**

1.  **Kernel Source (`linux/scripts/coccinelle/**/*.cocci`)**:

      * **Chunking**: 不要按行切割。按“规则块”切割。一个 `.cocci` 文件通常包含多个 `rule`。每个 `rule` 作为一个 Document。
      * **Metadata**: 提取 Header 中的 `///` 注释作为 Description。
      * **Tagging**: 自动打标：`type:api_removal`, `type:argument_change`, `complexity:low`.

2.  **Commit Log Mining (Diff-to-SmPL)**:

      * 爬取包含 "generated by coccinelle" 的 Commit。
      * **Input**: `a/file.c` vs `b/file.c` 的 Diff。
      * **Output**: 对应的 `.cocci` 脚本。
      * **Embedding**: 将 C Diff 和 Cocci Script 结对存储，用于 Few-Shot Learning。

### 3.2 工具层 (MCP / Tooling)

使用 Model Context Protocol (MCP) 或 LangChain Tools 定义确定性工具。

**Tool 1: `syntax_check`**

  * **Input**: `script_content` (string)
  * **Action**: 保存为 `temp.cocci`，运行 `spatch --parse-cocci temp.cocci`。
  * **Output**: 如果 exit code 为 0，返回 "OK"；否则返回 stderr 中的具体语法错误（如 "line 5: distinct types"）。

**Tool 2: `dry_run_verification`**

  * **Input**: `script_content` (string), `mock_c_code` (string)
  * **Action**:
    1.  保存 `temp.cocci` 和 `mock.c`。
    2.  运行 `spatch --sp-file temp.cocci mock.c`。
  * **Output**: 返回生成的 Patch 内容。如果输出为空，说明匹配失败。

-----

## 4\. Prompt Engineering 策略

### 4.1 Architect Agent (生成器) Prompt

核心在于**CoT (思维链)和去 C 化**。

```markdown
# System Prompt: SmPL Architect

You are a Senior Linux Kernel Engineer specializing in Coccinelle Semantic Patch Language (SmPL).
Your Goal: Write a `.cocci` script to automate a kernel refactoring task.

### STRICT RULES (SmPL != C):
1.  **Do NOT act like a C Compiler.** SmPL is a pattern matching language.
2.  **Metavariables are King:** You MUST declare all metavariables between `@@` and `@@` before using them.
    - `expression E;` matches specific values.
    - `identifier f;` matches function/variable names.
    - `type T;` matches data types.
3.  **The "..." Operator:** - Use `...` to match arbitrary code execution paths.
    - Use `<... ...>` for code that might execute multiple times (loops/nesting).
4.  **Handling Context:** Do not write surrounding code unless it is required for disambiguation.

### RAG CONTEXT:
Here are similar patterns from the Linux Kernel codebase:
{retrieved_docs}

### WORKFLOW:
1.  **Analyze**: Breakdown the transform logic (What is removed? What is added?).
2.  **Define**: List necessary metavariables.
3.  **Draft**: Write the full `.cocci` script.

User Request: {user_request}
```

### 4.2 Test Engineer (测试员) Prompt

用于生成验证代码。

```markdown
# System Prompt: Test Engineer

Your sole task is to create a **Minimal Reproducible Example (MRE)** in C language to test a specific Kernel API change.
1.  Do NOT fix the code. Write the "Old Code" that uses the deprecated API.
2.  Include dummy struct definitions if necessary so the code is syntactically plausible.
3.  Keep it short (under 20 lines).

User Request: {user_request}
```

-----

## 5\. LangGraph 工作流编排 (Implementation Logic)

以下是使用 Python/LangGraph 实现的伪代码逻辑：

```python
from langgraph.graph import StateGraph, END

# --- Node Functions ---

def retrieve_knowledge(state: AgentState):
    """Query VectorDB for similar .cocci patterns"""
    # implementation of vector search
    docs = vector_store.similarity_search(state['user_request'])
    return {"retrieved_docs": [d.page_content for d in docs]}

def draft_script(state: AgentState):
    """Architect Agent generates V1 script based on docs"""
    prompt = build_architect_prompt(state)
    response = llm.invoke(prompt)
    return {"cocci_script": extract_code(response), "status": "drafting"}

def generate_test_case(state: AgentState):
    """Test Engineer generates mock C code"""
    response = llm_test_gen.invoke(state['user_request'])
    return {"mock_c_code": extract_code(response)}

def validate_script(state: AgentState):
    """Tool Executor runs spatch --parse-cocci"""
    error = tools.syntax_check(state['cocci_script'])
    if error != "OK":
        return {"validation_output": error, "status": "syntax_error"}
    
    # If syntax is OK, run dry run
    patch = tools.dry_run(state['cocci_script'], state['mock_c_code'])
    if not patch.strip():
        return {"validation_output": "Script parsed but NO PATCH generated on mock code.", "status": "logic_error"}
    
    return {"patch_diff": patch, "status": "success"}

def refine_script(state: AgentState):
    """Architect Agent fixes script based on error log"""
    prompt = f"""
    The script you wrote failed validation.
    Current Script: {state['cocci_script']}
    Error Message: {state['validation_output']}
    
    Fix the syntax or relax the matching rules (e.g., change specific types to expressions).
    """
    response = llm.invoke(prompt)
    return {
        "cocci_script": extract_code(response), 
        "iteration_count": state['iteration_count'] + 1,
        "status": "fixing"
    }

# --- Graph Construction ---

workflow = StateGraph(AgentState)

# Add Nodes
workflow.add_node("retrieve", retrieve_knowledge)
workflow.add_node("architect", draft_script)
workflow.add_node("test_gen", generate_test_case)
workflow.add_node("validator", validate_script)
workflow.add_node("refiner", refine_script)

# Add Edges
workflow.set_entry_point("retrieve")
workflow.add_edge("retrieve", "test_gen") # Parallel capable
workflow.add_edge("test_gen", "architect")
workflow.add_edge("architect", "validator")

def router(state):
    if state['status'] == "success":
        return END
    if state['iteration_count'] > 5: # Safety break
        return END
    return "refiner"

workflow.add_conditional_edges("validator", router, {
    END: END,
    "refiner": "refiner"
})
workflow.add_edge("refiner", "validator")

app = workflow.compile()
```

-----

## 6\. 开发与落地指南

### 6.1 技术栈推荐

  * **LLM Model**: Claude 3.5 Sonnet (代码能力最强，对非主流语法适应性好) 或 GPT-4o。
  * **Orchestration**: LangGraph (Python)。
  * **Vector DB**: ChromaDB (轻量级，本地部署) 或 Milvus。
  * **Tools**:
      * `coccinelle` (需在运行环境安装 `spatch` 二进制)。
      * Python `subprocess` 模块用于调用 Shell。

### 6.2 关键实施步骤

1.  **数据清洗 (Day 1-2)**:
      * 下载 Linux Kernel 源码。
      * 编写 Python 脚本遍历 `scripts/coccinelle`，解析 header 注释和 rule body，构建 JSONL 数据集。
2.  **向量库搭建 (Day 3)**:
      * 使用 OpenAI `text-embedding-3-small` 或 HuggingFace `all-MiniLM-L6-v2` 对代码片段进行 Embedding。
3.  **Agent 编排 (Day 4-5)**:
      * 实现上述 LangGraph 逻辑。重点调试 `validator` 节点的反馈 Prompt，确保报错信息能引导 LLM 进行有效修正。
4.  **Mock 测试生成优化 (Day 6)**:
      * 这是最难的一步。如果 Mock 代码写得不对，脚本也是白写。可以考虑让 Test Engineer 也具备“自我反思”能力：如果 Patch 没生成，先检查 Mock 代码是否真的包含了应当被匹配的旧 API。

### 6.3 示例场景演示

**输入**: "Fix the usage of `usb_alloc_urb`. It now takes `gfp_flags` as the second argument, previously it took `iso_packets`."

1.  **Retrieve**: 找到 API 参数增加的类似 Cocci 脚本。
2.  **Draft**:
    ```cocci
    @@ expression E1, E2; @@
    - usb_alloc_urb(E1, E2)
    + usb_alloc_urb(E1, GFP_KERNEL) // 错误：丢弃了 E2，且硬编码了 Flag
    ```
3.  **Test Gen**: 生成 `mock.c` 包含 `struct urb *u = usb_alloc_urb(0, 10);`。
4.  **Validate**:
      * Dry Run: Patch 生成成功。
      * *高级检查*: Agent 发现 `E2` (iso\_packets) 丢失。
5.  **Refine (Self-Correction)**:
    ```cocci
    @@ expression packets, mem_flags; @@
    - usb_alloc_urb(packets, mem_flags) // 再次尝试理解旧签名
    + usb_alloc_urb(packets, GFP_KERNEL) 
    ```
    *注：此处需要 Agent A 准确理解 input 的语义，配合 RAG 检索正确的函数签名变更历史。*

## 7\. 总结

本设计通过引入 **Validator (spatch)** 作为客观真理，打破了 LLM 的“幻觉闭环”。通过 RAG 提供 SmPL 的“语法词典”，通过 LangGraph 实现“写-测-改”的自动化流程，能够极大地提高 Linux Kernel 语义补丁的生成成功率。
